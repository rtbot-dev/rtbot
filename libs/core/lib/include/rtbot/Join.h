#ifndef JOIN_H
#define JOIN_H

#include "Operator.h"

namespace rtbot {

/**
 * class Join is responsible for synchronizing many channels of Messages. This is a simple and intuitive implementation.
 * It uses as many queues as channels.
 *
 * The queues are updated every time a new message arrives:
 * 1. the old messages are removed.
 * 2. If all the incoming messages of the queues match the current time stamp, then a message is generated by
 * concatenating them.
 *
 * To implement any Operator that requires synchronizing many channels of messages
 * the user should just inherit from Join and override the method processData(msg) where the ready-to-use message msg is
 * given.
 */
template <class T, class V>
class Join : public Operator<T, V> {
 public:
  Join() = default;
  Join(string const &id) : Operator<T, V>(id) {}
  Join(string const &id, size_t numPorts, map<string, typename Operator<T, V>::InputPolicy> policies = {})
      : Operator<T, V>(id) {
    if (numPorts < 2) throw std::runtime_error(typeName() + ": number of ports have to be greater than or equal 2");

    int eagerInputs = 0;
    for (int i = 1; i <= numPorts; i++) {
      string inputPort = string("i") + to_string(i);
      string outputPort = string("o") + to_string(i);
      if (policies.count(inputPort) > 0) {
        if (policies.find(inputPort)->second.isEager()) eagerInputs++;
        this->addDataInput(inputPort, 0, policies.find(inputPort)->second);
      } else
        this->addDataInput(inputPort, 0, {});
      this->addOutput(outputPort);
    }
    if (eagerInputs == numPorts)
      throw std::runtime_error(typeName() + ": at least one input port should be not eager.");
  }
  virtual ~Join() = default;

  virtual string typeName() const override { return "Join"; }

  map<string, std::vector<Message<T, V>>> receiveData(Message<T, V> const &msg, string inputPort = "") override {
    if (inputPort.empty()) {
      throw std::runtime_error(typeName() + " : inputPort have to be specified");
    }

    if (this->dataInputs.count(inputPort) > 0) {
      if (this->dataInputs.find(inputPort)->second.isEager() && !this->dataInputs.find(inputPort)->second.empty()) {
        this->dataInputs.find(inputPort)->second.setSum(this->dataInputs.find(inputPort)->second.getSum() -
                                                        this->dataInputs.find(inputPort)->second.front().value);
        this->dataInputs.find(inputPort)->second.pop_front();
      }
      this->dataInputs.find(inputPort)->second.push_back(msg);
      this->dataInputs.find(inputPort)->second.setSum(this->dataInputs.find(inputPort)->second.getSum() +
                                                      this->dataInputs.find(inputPort)->second.back().value);
    } else
      throw std::runtime_error(typeName() + ": " + inputPort + " refers to a non existing input port");

    for (auto it = this->dataInputs.begin(); it != this->dataInputs.end(); ++it) {
      if (it->first == inputPort || it->second.isEager()) continue;
      while (!it->second.empty() &&
             (it->second.front().time < msg.time && !this->dataInputs.find(inputPort)->second.isEager())) {
        it->second.setSum(it->second.getSum() - it->second.front().value);
        it->second.pop_front();
      }
    }

    bool all_ready = true;
    for (auto it = this->dataInputs.begin(); it != this->dataInputs.end(); ++it) {
      if (it->second.empty() || (it->second.front().time > msg.time && !it->second.isEager() &&
                                 !this->dataInputs.find(inputPort)->second.isEager()))
        all_ready = false;
    }

    if (all_ready) {
      auto toEmit = processData(inputPort);
      for (auto it = this->dataInputs.begin(); it != this->dataInputs.end(); ++it) {
        if (!it->second.isEager()) {
          it->second.setSum(it->second.getSum() - it->second.front().value);
          it->second.pop_front();
        }
      }
      return this->emit(toEmit);
    }
    return {};
  }

  /*
    map<outputPort, vector<Message<T, V>>>
  */
  virtual map<string, vector<Message<T, V>>> processData(string inputPort) {
    map<string, vector<Message<T, V>>> outputMsgs;

    int i = 1;
    for (auto it = this->dataInputs.begin(); it != this->dataInputs.end(); ++it) {
      vector<Message<T, V>> v;
      v.push_back(it->second.front());
      outputMsgs.emplace(string("o") + to_string(i), v);
      i++;
    }

    return outputMsgs;
  }
};

}  // end namespace rtbot

#endif  // JOIN_H
