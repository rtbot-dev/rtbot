#ifndef JOIN_H
#define JOIN_H

#include <queue>
#include <unordered_map>

#include "Operator.h"

namespace rtbot {

/**
 * class Join is responsible for synchronizing many channels of Messages. This is a simple and intuitive implementation.
 * It uses as many queues as channels.
 *
 * The queues are updated every time a new message arrives:
 * 1. the old messages are removed.
 * 2. If all the incoming messages of the queues match the current time stamp, then a message is generated by
 * concatenating them.
 *
 * To implement any Operator that requires synchronizing many channels of messages
 * the user should just inherit from Join and override the method processData(msg) where the ready-to-use message msg is
 * given.
 */
template <class T = double>
class Join : public Operator<T> {
  vector<std::queue<Message<T>>> data;  //< the waiting Messages for each port
 public:
  int nInput = 2;
  using Operator<T>::Operator;
  Join(string const &id_, int nInput_) : Operator<T>(id_), nInput(nInput_) {}
  virtual ~Join() = default;

  virtual string typeName() const override { return "Join"; }

  map<string, std::vector<Message<T>>> receive(Message<T> const &msg, int port) override {
    // add the incoming message to the correct channel
    if (nInput > data.size()) data.resize(nInput);
    data.at(port).push(msg);

    // remove old messages
    for (auto i = 0u; i < data.size(); i++) {
      if (i == port) continue;
      while (!data[i].empty() && data[i].front().time < msg.time) data[i].pop();
    }

    // check if all queue match the current time
    bool all_ready = true;
    for (const auto &x : data)
      if (x.empty() || x.front().time > msg.time) all_ready = false;

    if (all_ready) return processData(makeMessage());
    return {};
  }

  /**
   *  This is a replacement of Operator::receive but using the already synchronized data provided in msg
   *  It is responsible to emit().
   */
  virtual map<string, std::vector<Message<T>>> processData(Message<T> const &msg) {
    std::vector<Message<>> msgs;
    msgs.push_back(msg);
    return this->emit(msgs);
  };

 private:
  // build a message by concatenating all channels front() data. Remove the used data.
  Message<T> makeMessage() {
    Message<T> msg;
    msg.time = data.at(0).front().time;
    for (const auto &x : data)
      for (const T &xi : x.front().value) msg.value.push_back(xi);

    for (auto &x : data) x.pop();
    return msg;
  }
};

/**
 * @brief The Difference class as example of application of Join
 */
struct Difference : public Join<double> {
  Difference(string const &id_ = "diff") : Join(id_, 2) {}

  string typeName() const override { return "Difference"; }

  map<string, std::vector<Message<>>> processData(Message<double> const &msg) override {
    Message<> out(msg.time, msg.value.at(0) - msg.value.at(1));
    std::vector<Message<>> msgs;
    msgs.push_back(out);
    return emit(msgs);
  }
};

}  // end namespace rtbot

#endif  // JOIN_H
