#ifndef JOIN_H
#define JOIN_H

#include <queue>
#include <unordered_map>

#include "Operator.h"

namespace rtbot {

/**
 * class Join is responsible for synchronizing many channels of Messages. This is a simple and intuitive implementation.
 * It uses as many queues as channels.
 *
 * The queues are updated every time a new message arrives:
 * 1. the old messages are removed.
 * 2. If all the incoming messages of the queues match the current time stamp, then a message is generated by
 * concatenating them.
 *
 * To implement any Operator that requires synchronizing many channels of messages
 * the user should just inherit from Join and override the method processData(msg) where the ready-to-use message msg is
 * given.
 */
template <class T, class V>
class Join : public Operator<T, V> {
  vector<std::queue<Message<T, V>>> data;  // the waiting Messages for each port
 public:
  size_t numPorts;
  using Operator<T, V>::Operator;
  Join(string const &id_, int numPorts_) : Operator<T, V>(id_) {
    if (numPorts_ < 2) throw std::runtime_error(typeName() + ": number of ports have to be greater than or equal 2");
    data.resize(numPorts_);
    numPorts = numPorts_;
  }
  virtual ~Join() = default;

  virtual string typeName() const override { return "Join"; }

  map<string, std::vector<Message<T, V>>> receive(Message<T, V> const &msg, int port) override {
    // add the incoming message to the correct channel

    if (port > data.size() - 1 || port < 0) throw std::runtime_error(typeName() + ": port out of index");

    data.at(port).push(msg);

    // remove old messages
    for (auto i = 0u; i < data.size(); i++) {
      if (i == port) continue;
      while (!data[i].empty() && data[i].front().time < msg.time) data[i].pop();
    }

    // check if all queue match the current time
    bool all_ready = true;
    for (const auto &x : data)
      if (x.empty() || x.front().time > msg.time) all_ready = false;

    if (all_ready) return processData(makeMessage());
    return {};
  }

  /**
   *  This is a replacement of Operator::receive but using the already synchronized data provided in msg
   *  It is responsible to emit().
   */
  virtual map<string, std::vector<Message<T, V>>> processData(vector<Message<T, V>> const &msgs) {
    return this->emitParallel(msgs);
  }

 private:
  // build a message by concatenating all channels front() data. Remove the used data.
  vector<Message<T, V>> makeMessage() {
    vector<Message<T, V>> msgs;
    for (const auto &x : data) msgs.push_back(x.front());

    for (auto &x : data) x.pop();

    return msgs;
  }
};

}  // end namespace rtbot

#endif  // JOIN_H
