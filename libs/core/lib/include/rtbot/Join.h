#ifndef JOIN_H
#define JOIN_H

#include <queue>
#include <unordered_map>
#include "Operator.h"

namespace rtbot {


/**
 * class Join is responsible for synchronizing many channels of Messages. This is a simple and intuitive implementation.
 * It uses as many queues as channels.
 *
 * The queues are updated every time a new message arrives:
 * 1. the old messages are removed.
 * 2. If all the incoming messages of the queues match the current time stamp, then a message is generated by concatenating them.
 *
 * To implement any Operator that requires synchronizing many channels of messages
 * the user should just inherit from Join and override the method processData(msg) where the ready-to-use message msg is given.
 */
template<class T=double>
class Join : public Operator<T>
{
    std::unordered_map<const Operator<T> *, std::queue<Message<T>>> data; //< the waiting Messages for each sender
public:
    using Operator<T>::Operator;
    virtual ~Join()=default;

    virtual string typeName() const override { return "Join"; }

    void addSender(const Operator<T> *sender) override { data[sender]; }

    map<string,Message<T>> receive(Message<T> const &msg, const Operator<T> *sender) override
    {
        // add the incoming message to the correct channel
        data.at(sender).push(msg);

        // remove old messages
        for (auto &x : data) {
            if (x.first==sender) continue;
            while (!x.second.empty() && x.second.front().time < msg.time)
                x.second.pop();
        }

        // check if all queue match the current time
        bool all_ready = true;
        for (const auto &x : data)
            if (x.second.empty() || x.second.front().time > msg.time)
                all_ready = false;

        if (all_ready)
            return processData(makeMessage());
        return {};
    }


    /**
     *  This is a replacement of Operator::receive but using the already synchronized data provided in msg
     *  It is responsible to emit().
     */
    virtual map<string,Message<T>> processData(Message<T> const &msg) {
        std::vector<Message<>> msgs;
        msgs.push_back(msg);            
        return this->emit(msgs);
    };

private:
    // build a message by concatenating all channels front() data. Remove the used data.
    Message<T> makeMessage()
    {
        Message<T> msg;
        msg.time = data.begin()->second.front().time;
        for (const auto &x : data)
            for (const T &xi : x.second.front().value)
                msg.value.push_back(xi);

        for (auto &x : data)
            x.second.pop();
        return msg;
    }
};


/**
 * @brief The Difference class as example of application of Join
 */
struct Difference: public Join<double>
{
    using Join<double>::Join;

    string typeName() const override { return "Difference"; }

    map<string,Message<>> processData(Message<double> const &msg) override
    {
        Message<> out(msg.time, msg.value.at(1)-msg.value.at(0));
        std::vector<Message<>> msgs;
        msgs.push_back(out);
        return emit(msgs);        
    }
};


} // end namespace rtbot


#endif // JOIN_H
