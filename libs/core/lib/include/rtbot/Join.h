#ifndef JOIN_H
#define JOIN_H

#include <queue>
#include <unordered_map>

#include "Operator.h"

namespace rtbot {

/**
 * class Join is responsible for synchronizing many channels of Messages. This is a simple and intuitive implementation.
 * It uses as many queues as channels.
 *
 * The queues are updated every time a new message arrives:
 * 1. the old messages are removed.
 * 2. If all the incoming messages of the queues match the current time stamp, then a message is generated by
 * concatenating them.
 *
 * To implement any Operator that requires synchronizing many channels of messages
 * the user should just inherit from Join and override the method processData(msg) where the ready-to-use message msg is
 * given.
 */
template <class T = double>
class Join : public Operator<T> {
  vector<std::queue<Message<T>>> data;  //< the waiting Messages for each port
 public:
  int nInput = 2;
  using Operator<T>::Operator;
  Join(string const &id_, int nInput_) : Operator<T>(id_), nInput(nInput_) {}
  virtual ~Join() = default;

  virtual string typeName() const override { return "Join"; }

  map<string, std::vector<Message<T>>> receive(Message<T> const &msg, int port) override {
    // add the incoming message to the correct channel
    if (nInput > data.size()) data.resize(nInput);
    data.at(port).push(msg);

    // remove old messages
    for (auto i = 0u; i < data.size(); i++) {
      if (i == port) continue;
      while (!data[i].empty() && data[i].front().time < msg.time) data[i].pop();
    }

    // check if all queue match the current time
    bool all_ready = true;
    for (const auto &x : data)
      if (x.empty() || x.front().time > msg.time) all_ready = false;

    if (all_ready) return processData(makeMessage());
    return {};
  }

  /**
   *  This is a replacement of Operator::receive but using the already synchronized data provided in msg
   *  It is responsible to emit().
   */
  virtual map<string, std::vector<Message<T>>> processData(vector<Message<T>> const& msgs) { return this->emitParallel(msgs); }

 private:
  // build a message by concatenating all channels front() data. Remove the used data.
  vector<Message<T>> makeMessage() {
    vector<Message<T>> msgs;
    for (const auto &x : data)
      msgs.push_back(x.front());

    for (auto &x : data) x.pop();

    return msgs;
  }
};

/**
 * @brief The Difference class as example of application of Join
 */
struct Difference : public Join<double> {
  Difference(string const &id_ = "diff") : Join(id_, 2) {}

  string typeName() const override { return "Difference"; }

  map<string, std::vector<Message<>>> processData(vector<Message<double>> const &msgs) override {
    Message<> out(msgs.at(0).time, msgs.at(0).value[0] - msgs.at(1).value[0]);
    return emit(out);
  }
};

}  // end namespace rtbot

#endif  // JOIN_H
